Index: ../.idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../.idea/modules.xml b/../.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1676844652289)
+++ b/../.idea/modules.xml	(date 1676844652289)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/CS149-HomeRepo-Spring-2023.iml" filepath="$PROJECT_DIR$/.idea/CS149-HomeRepo-Spring-2023.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: ../Assignments/A1/countnames.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\n * Description:\n * Assume that you have a text file with a name on each line,\n * and names are separated by newlines. Assume each row has one name (keep things simple) and a name can occur\n * many times in the file. Assume you are dealing with up to 100 individual names (since you would need dynamic\n * memory allocation for expanding an array to deal with more names, which we'll see later). You want to read the\n * names in and count the occurrences of each. Since we want to be flexible on the type and size of characters we\n * can handle, you can assume Ascii code and you expect a file to contain simple characters of Ascii values from\n * 0-128. A name can be up to 30 characters long.\n You must be able to handle a file with any number of rows, including no names. It is ok if this is slow\n (since you would need dynamic data structures like hash tables to make it fast, which we'll see later). You can\n assume that the input file contains only valid characters and rows are separated by newlines; the input file may\n contain a few empty lines as well (which you will ignore).\n *\n * Author Names:\n * Diego Cruz\n * Saim Sheikh\n *\n * Author emails:\n * diego.cruz@sjsu.edu\n * saim.sheikh@sjsu.edu\n *\n * Last Modified: 2/12/2023\n * Creation Date: 2/12/2023\n */\n#include<stdio.h>\n#include<string.h>\nint main(int argc, char *argv[]) {\n    //argc and argv are how command line arguments are passed to main(0 in C/C++.\n    //Argc will be # of strings pointed to by argv\n    //Argv = pointer\n    const char *filename=argv[1];   //filename is taken as argument, pointer reference, assume each line max 30 char\n    char length[30];\n    char names[100][30];    //100 by 30 2D array        character array\n\n    int counter[100];\n    int i, j,k;\n\n\n    FILE *file = fopen(filename, \"r\");\n    if(file == NULL) {\n        printf(\"Not able to open the file.\");\n        return -1;\n    }\n    else{\n        printf(\"Opening the file...\");\n    }\n    // DC Note\n    // Brute force loop to traverse through the array looking for a particular name value\n    // and add to the counter array, has a flaw in that it will double-count arrays in the file\n    /*FGET from https://www.w3schools.com/c/c_files_read.php\n     * The first parameter specifies where to store the file content, which will be in the length array we just created.\n    The second parameter specifies the maximum size of data to read, which should match the size of length [30].\n    The third parameter requires a file pointer that is used to read the file (fptr in our example).\n     *\n     */\n\n\n    //REMOVES NEW LINE FROM FGETS AND COPES LINE with name as long as not empty.\n    while(fgets(length,30,file)){      //fgets reads and includes new line character\n        char *ret = strchr(length, '\\n');   //searches for first occurence of '\\n' to replace with 0\n        // can also use  char *key_word = (char*)malloc(sizeof(char) * SIZE);\n        // and then      key_word[strlen(key_word) - 1] = '\\0'; to remove new lines\n        if (ret){\n            *ret  = '\\0';\n        }\n         j=0;\n        if (strlen(length) != 0){                   //if the line is not empty copy the name and length\n            strcpy(names[j], length);\n            j++;\n        }\n        else {\n            printf(stderr, \"[WARNING] : Line %d is empty\\n\", j);\n        }\n    }\n\n    // Need to find method to get unique names and then stop looking for those unique names once they've already been searched\n    // Not sure if Strcmp will play nice with the char array we've got, despite the fact that this is how they handle strings in C\n    //Updating counter for duplicate names while also removing the duplicates, finally print at end of looping through character array\n    int count = 0;\n    for (i = 0; i < j; i++) {       //loop through lines of names\n        for (k = i+1; k < j; k++) {\n            if (strcmp(names[i], names[k]) ==       //check if same line\n                0) {// Native C library function to use Strcmp, returns 0 if the strings are the same\n                count++;            //if names are equal/match, count up.\n                counter[k] = 0;     //reset\n            }\n        }\n        if (counter[i]==0){\n            counter[i]=count;\n        }\n\n        for(i=0;i<j;i++){\n            if (counter[i]!=0){\n                fprintf(\"%s: %d\\n\", names[i], counter[i]);\n            }\n        }\n\n        fclose(file);\n        return 0;\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Assignments/A1/countnames.c b/../Assignments/A1/countnames.c
--- a/../Assignments/A1/countnames.c	(revision a2de1f31505f68497f76645c519b9c0b2e5a7b23)
+++ b/../Assignments/A1/countnames.c	(date 1676847417420)
@@ -34,7 +34,8 @@
     char names[100][30];    //100 by 30 2D array        character array
 
     int counter[100];
-    int i, j,k;
+    int i=0;
+    int j= 0;
 
 
     FILE *file = fopen(filename, "r");
@@ -42,9 +43,8 @@
         printf("Not able to open the file.");
         return -1;
     }
-    else{
-        printf("Opening the file...");
-    }
+
+
     // DC Note
     // Brute force loop to traverse through the array looking for a particular name value
     // and add to the counter array, has a flaw in that it will double-count arrays in the file
@@ -55,49 +55,57 @@
      *
      */
 
+    for (int i = 0; i < 100; i++) {
+        counter[i] = -1;
+    }
 
-    //REMOVES NEW LINE FROM FGETS AND COPES LINE with name as long as not empty.
+    //removes new line in fgets and copies the name as long if not empty.
     while(fgets(length,30,file)){      //fgets reads and includes new line character
         char *ret = strchr(length, '\n');   //searches for first occurence of '\n' to replace with 0
-        // can also use  char *key_word = (char*)malloc(sizeof(char) * SIZE);
-        // and then      key_word[strlen(key_word) - 1] = '\0'; to remove new lines
+        // can also use  if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = '\0';
+        //https://aticleworld.com/remove-trailing-newline-character-from-fgets/   Links to an external site.
         if (ret){
             *ret  = '\0';
         }
-         j=0;
-        if (strlen(length) != 0){                   //if the line is not empty copy the name and length
+
+        if (strlen(length) != 0){                   //if the line is not empty copy the pointer and str name to be copied
             strcpy(names[j], length);
             j++;
         }
         else {
-            printf(stderr, "[WARNING] : Line %d is empty\n", j);
+            fprintf(stderr, "[WARNING] : Line %d is empty\n", j);
         }
     }
+
+
 
     // Need to find method to get unique names and then stop looking for those unique names once they've already been searched
     // Not sure if Strcmp will play nice with the char array we've got, despite the fact that this is how they handle strings in C
+
     //Updating counter for duplicate names while also removing the duplicates, finally print at end of looping through character array
-    int count = 0;
+
+
     for (i = 0; i < j; i++) {       //loop through lines of names
-        for (k = i+1; k < j; k++) {
+        int count = 1;
+        for (int k = i + 1; k < j; k++) {
             if (strcmp(names[i], names[k]) ==       //check if same line
                 0) {// Native C library function to use Strcmp, returns 0 if the strings are the same
                 count++;            //if names are equal/match, count up.
                 counter[k] = 0;     //reset
             }
         }
-        if (counter[i]==0){
-            counter[i]=count;
+        if (counter[i] != 0) {
+            counter[i] = count;     //updating count
         }
-
-        for(i=0;i<j;i++){
-            if (counter[i]!=0){
-                fprintf("%s: %d\n", names[i], counter[i]);
-            }
-        }
+    }
+    // Print: names + occurences
+    for(i=0;i<j;i++){
+        if (counter[i]!=0){
+            printf("%s: %d\n", names[i], counter[i]);
+        }
+    }
 
-        fclose(file);
-        return 0;
-    }
+    fclose(file);
+    return 0;
+}
 
-}
\ No newline at end of file
Index: ../.idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../.idea/vcs.xml b/../.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1676844652285)
+++ b/../.idea/vcs.xml	(date 1676844652285)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/Worksheets" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/Worksheets/worksheet02" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
